@page "/sudoku"
@layout MainLayout
@inject IJSRuntime JSRuntime
<h3>Sudoku</h3>

<div class="sudoku-controls">
    <input type="number" @bind="numberCount" min="1" max="81" placeholder="Number of cells to fill" />
    <button @onclick="GenerateRandomNumbers">Generate Random Numbers</button>
    <button @onclick="SolveAndDisplayBacktracking">Solve with Backtracking</button>
    <button @onclick="SolveAndDisplayArcConsistency">Solve with Arc Consistency + Backtracking</button>
    <button @onclick="ClearGrid">Clear the Grid</button>
</div>

<div class="sudoku-grid">
    @for (int row = 0; row < 9; row++)
    {
        <div class="sudoku-row">
            @for (int col = 0; col < 9; col++)
            {
                <input type="text" class="sudoku-cell" @bind="grid[row][col]" maxlength="1" />
            }
        </div>
    }
</div>

@if (!string.IsNullOrEmpty(solutionMessage))
{
    <div class="solution-message">
        @solutionMessage
    </div>
}

<canvas id="myChart" width="400" height="200"></canvas>

<style>
    .sudoku-controls {
        margin-bottom: 20px;
    }

    .sudoku-controls input {
        padding: 5px;
        margin-right: 10px;
        width: 200px;
    }

    .sudoku-controls button {
        padding: 5px 10px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
        margin-right: 5px;
    }

    .sudoku-controls button:hover {
        background-color: #0056b3;
    }

    .sudoku-grid {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .sudoku-row {
        display: flex;
    }

    .sudoku-cell {
        width: 40px;
        height: 40px;
        text-align: center;
        font-size: 18px;
        border: 1px solid #ccc;
        margin: 1px;
    }

    .sudoku-cell:focus {
        outline: none;
        border-color: #66afe9;
        box-shadow: 0 0 8px rgba(102, 175, 233, 0.6);
    }

    .solution-message {
        margin-top: 20px;
        font-size: 18px;
        font-weight: bold;
        color: #007bff;
    }
</style>

@code {
    // private static int N = 9; // Now in SudokuLogic
    private List<List<string>> grid = new List<List<string>>(); // 9x9 grid to store Sudoku values
    private int numberCount = 10; // Default number of cells to fill
    private string solutionMessage = "";

    // private Random random = new Random(); // Now in SudokuLogic
    private SudokuLogic sudokuLogic = new SudokuLogic();

    // Fields for chart timings
    private long backtrackingTimeMs = 0;
    private long ac3BacktrackingTimeMs = 0;

    protected override void OnInitialized()
    {
        for (int i = 0; i < SudokuLogic.N; i++) // Use SudokuLogic.N
        {
            grid.Add(new List<string>());
            for (int j = 0; j < SudokuLogic.N; j++) // Use SudokuLogic.N
                grid[i].Add("");
        }
    }

    // -----------------------------------------------------
    // 1) RANDOM NUMBER GENERATION
    // -----------------------------------------------------
    // GenerateFullSolution is now in SudokuLogic

    private void GenerateRandomNumbers()
    {
        ClearGrid(); // Start with an empty grid

        int[,] solvedBoard = new int[SudokuLogic.N, SudokuLogic.N];
        // bool solutionGenerated = GenerateFullSolution(solvedBoard, 0, 0); // Call from sudokuLogic
        bool solutionGenerated = sudokuLogic.GenerateFullSolution(solvedBoard, 0, 0);


        if (solutionGenerated)
        {
            // Create a list of all cell coordinates
            List<(int r, int c)> allCells = new List<(int, int)>();
            for (int r = 0; r < SudokuLogic.N; r++)
            {
                for (int c = 0; c < SudokuLogic.N; c++)
                {
                    allCells.Add((r, c));
                }
            }

            // Shuffle the cell coordinates - SudokuLogic has its own Random instance.
            // If we want to use that one, GenerateRandomNumbers would need to be part of SudokuLogic
            // or Random be passed. For now, let's create a local Random for shuffling here if needed,
            // or accept that GenerateFullSolution's randomness is sufficient.
            // The existing GenerateFullSolution in SudokuLogic uses its own random instance.
            // The shuffling of cells to pick for the puzzle can use a new Random instance here.
            var localRandom = new Random();
            allCells = allCells.OrderBy(x => localRandom.Next()).ToList();


            // Determine how many cells to keep based on numberCount
            // numberCount is "Number of cells to fill"
            int cellsToKeep = Math.Max(1, Math.Min(81, numberCount));

            // Fill the grid with numbers from the solvedBoard
            for (int i = 0; i < cellsToKeep; i++)
            {
                var (r, c) = allCells[i];
                grid[r][c] = solvedBoard[r, c].ToString();
            }
            solutionMessage = $"Generated a puzzle with {cellsToKeep} clues.";
        }
        else
        {
            solutionMessage = "Error: Could not generate a full Sudoku solution.";
        }
        StateHasChanged();
    }

    // -----------------------------------------------------
    // 2) CLEAR GRID
    // -----------------------------------------------------
    private void ClearGrid()
    {
        for (int row = 0; row < SudokuLogic.N; row++) // Use SudokuLogic.N
            for (int col = 0; col < SudokuLogic.N; col++) // Use SudokuLogic.N
                grid[row][col] = "";
        solutionMessage = "";
    }

    // -----------------------------------------------------
    // 3) BACKTRACKING SOLVER
    // -----------------------------------------------------
    // SolveSudokuBacktracking is now in SudokuLogic
    // IsSafe is now in SudokuLogic

    private void SolveAndDisplayBacktracking()
    {
        // Convert List<List<string>> to int[,]
        int[,] intGrid = ConvertTo2DIntArray();

        var sw = System.Diagnostics.Stopwatch.StartNew();

        // bool solved = SolveSudokuBacktracking(intGrid, 0, 0); // Call from sudokuLogic
        bool solved = sudokuLogic.SolveSudokuBacktracking(intGrid, 0, 0);


        sw.Stop();
        long timeMs = sw.ElapsedMilliseconds;
        this.backtrackingTimeMs = timeMs;

        if (solved)
        {
            // Update the grid with the solution
            ConvertToListOfString(intGrid);
            solutionMessage = $"Backtracking: Solved in {timeMs} ms!";
        }
        else
        {
            solutionMessage = $"Backtracking: No solution found. (Time: {timeMs} ms)";
        }
        await UpdateSolutionTimesChart();
        StateHasChanged();
    }


    // We'll keep a dictionary: (row, col) -> HashSet<int> representing the domain of each cell
    // This 'domains' dictionary is now managed by the SudokuLogic instance.
    // Methods like InitializeDomains, AC3, Revise, GetNeighbors, BacktrackingWithAC3, CopyDomains
    // are all part of SudokuLogic.

    private void SolveAndDisplayArcConsistency()
    {
        // Convert to int array from UI
        int[,] intGrid = ConvertTo2DIntArray();

        // Initialize domains based on the current board using the SudokuLogic instance
        sudokuLogic.InitializeDomains(intGrid);


        var sw = System.Diagnostics.Stopwatch.StartNew();

        // bool solved = BacktrackingWithAC3(intGrid); // Call from sudokuLogic
        bool solved = sudokuLogic.BacktrackingWithAC3(intGrid);


        sw.Stop();
        long timeMs = sw.ElapsedMilliseconds;
        this.ac3BacktrackingTimeMs = timeMs;

        if (solved)
        {
            // Convert back to string grid for display
            ConvertToListOfString(intGrid);
            solutionMessage = $"AC + Backtracking: Solved in {timeMs} ms!";
        }
        else
        {
            solutionMessage = $"AC + Backtracking: No solution found. (Time: {timeMs} ms)";
        }
        await UpdateSolutionTimesChart();
        StateHasChanged();
    }

    private async Task UpdateSolutionTimesChart()
    {
        var labels = new string[] { "Backtracking", "AC3 + Backtracking" };
        var data = new double[] { this.backtrackingTimeMs, this.ac3BacktrackingTimeMs };

        await JSRuntime.InvokeVoidAsync("timeChartFunctions.updateChart", "myChart", labels, data);
    }


    // -----------------------------------------------------
    // 6) HELPER CONVERSIONS
    // -----------------------------------------------------
    private int[,] ConvertTo2DIntArray()
    {
        int[,] intGrid = new int[SudokuLogic.N, SudokuLogic.N]; // Use SudokuLogic.N
        for (int i = 0; i < SudokuLogic.N; i++)
        {
            for (int j = 0; j < SudokuLogic.N; j++)
            {
                if (string.IsNullOrEmpty(grid[i][j]))
                    intGrid[i, j] = 0;
                else
                {
                    if (int.TryParse(grid[i][j], out int val))
                        intGrid[i, j] = val;
                    else
                        intGrid[i, j] = 0; // or handle invalid input
                }
            }
        }
        return intGrid;
    }

    private void ConvertToListOfString(int[,] intGrid)
    {
        for (int i = 0; i < SudokuLogic.N; i++) // Use SudokuLogic.N
        {
            for (int j = 0; j < SudokuLogic.N; j++) // Use SudokuLogic.N
            {
                if (intGrid[i, j] == 0)
                    grid[i][j] = "";
                else
                    grid[i][j] = intGrid[i, j].ToString();
            }
        }
    }
}
